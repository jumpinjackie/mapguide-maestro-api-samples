using OSGeo.MapGuide.MaestroAPI;
using OSGeo.MapGuide.MaestroAPI.Mapping;
using OSGeo.MapGuide.MaestroAPI.Services;
using OSGeo.MapGuide.ObjectModels.LayerDefinition;
using System.Collections.Specialized;
using System.Drawing;

namespace MvcCoreSample.Models;

public static class SamplesHelper
{
    static Random rand = new Random();

    static Color RandomColor()
    {
        return Color.FromArgb(rand.Next(0, 256), rand.Next(0, 256), rand.Next(0, 256));
    }

    internal static RuntimeMap OpenMap<T>(IServerConnection conn, T model)
        where T : CommonInvokeUrlRequestModel
    {
        var mpSvc = (IMappingService)conn.GetService((int)ServiceType.Mapping);
        string rtMapId = "Session:" + model.Session + "//" + model.MapName + ".Map";
        var rtMap = mpSvc.OpenMap(rtMapId);
        return rtMap;
    }

    internal static void CreateTracksLayer(IServerConnection conn, string resId, string layerId)
    {
        //We use the Utility class to create our layer. You can also use ObjectFactory, but
        //that requires explicitly specifying the resource version. Using Utility will pick
        //the latest supported version
        var ldf = Utility.CreateDefaultLayer(conn, LayerType.Vector);
        var vldf = (IVectorLayerDefinition)ldf.SubLayer;

        //Set feature source
        vldf.ResourceId = resId;

        //Set the feature class
        vldf.FeatureName = "SHP_Schema:Rail";

        //Set the designated geometry
        vldf.Geometry = "SHPGEOM";

        //Get the first vector scale range. This will have been created for us and is 0 to infinity
        var vsr = vldf.GetScaleRangeAt(0);

        //Get the line style
        var lstyle = vsr.LineStyle;

        //Get the first rule (a created one will only have one)
        var rule = lstyle.GetRuleAt(0);

        //What are we doing here? We're checking if this vector scale range is a
        //IVectorScaleRange2 instance. If it is, it means this layer definition
        //has a composite style attached, which takes precedence over point/area/line
        //styles. We don't want this, so this removes the composite styles if they
        //exist.
        var vsr2 = vsr as IVectorScaleRange2;
        if (vsr2 != null)
            vsr2.CompositeStyle = null;

        //There's only one stroke here, but iteration is the only
        //way to go through
        foreach (var stroke in rule.Strokes)
        {
            //Set color to red
            stroke.Color = "ffff0000";
        }

        //Now save it
        conn.ResourceService.SaveResourceAs(ldf, layerId);
    }

    internal static void CreateDistrictsLayer(IServerConnection conn, string resId, string layerId)
    {
        //We use the Utility class to create our layer. You can also use ObjectFactory, but
        //that requires explicitly specifying the resource version. Using Utility will pick
        //the latest supported version
        var ldf = Utility.CreateDefaultLayer(conn, LayerType.Vector);
        var vldf = (IVectorLayerDefinition)ldf.SubLayer;

        //Set feature source
        vldf.ResourceId = resId;

        //Set the feature class 
        //
        //Note: In versions of the Sheboygan Dataset before 2.6, this used to be
        //
        // - Feature Class: SDF_2_Schema:VotingDistricts
        // - Identity Property: Autogenerated_SDF_ID
        // - Geometry Property: Data
        string featureClass = "Default:VotingDistricts";
        string idProp = "FeatId";
        string geometryProp = "Geometry";
        vldf.FeatureName = featureClass;

        //Set the designated geometry
        vldf.Geometry = geometryProp;

        //Get the first vector scale range. This will have been created for us and is 0 to infinity
        var vsr = vldf.GetScaleRangeAt(0);

        //What are we doing here? We're checking if this vector scale range is a
        //IVectorScaleRange2 instance. If it is, it means this layer definition
        //has a composite style attached, which takes precedence over point/area/line
        //styles. We don't want this, so this removes the composite styles if they
        //exist.
        var vsr2 = vsr as IVectorScaleRange2;
        if (vsr2 != null)
            vsr2.CompositeStyle = null;

        //Get the area style
        IAreaVectorStyle astyle = vsr.AreaStyle;
        //Remove the default rule
        astyle.RemoveAllRules();

        var featSvc = conn.FeatureService;
        //Generate a random color for each distinct feature id
        //Perform a distinct value query
        var valueReader = featSvc.AggregateQueryFeatureSource(resId, featureClass, null, new NameValueCollection()
        {
            { "Value", "UNIQUE(" + idProp + ")" } //UNIQUE() is the aggregate function that collects all distinct values of FeatId
        });

        while (valueReader.ReadNext())
        {
            //The parent Layer Definition provides all the methods needed to create the necessary child elements
            var rule = ldf.CreateDefaultAreaRule();
            //Set the filter for this rule
            rule.Filter = idProp + " = " + valueReader["Value"].ToString();
            //IReader allows object access by name in case you don't care to determine the data type
            rule.LegendLabel = valueReader["Value"].ToString();
            //Assign a random color fill
            rule.AreaSymbolization2D.Fill.ForegroundColor = Utility.SerializeHTMLColor(RandomColor(), true);
            //Add this rule
            astyle.AddRule(rule);
        }
        valueReader.Close();

        //Now save it
        conn.ResourceService.SaveResourceAs(ldf, layerId);
    }
}
